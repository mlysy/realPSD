---
title: "Tests of fitSHOW method"
author: "Feiyu Zhu"
date: 
link-citations: true
output: 
  pdf_document:
    number_sections: true
    fig_caption: true
vignette: >
  %\VignetteIndexEntry{test}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = '80%', fig.align='center')
suppressMessages(require(realPSD))
suppressMessages(require(tidyverse))
suppressMessages(require(optimCheck))
```

# Check the empirical PSD matches up with the analytic one.

First we list some physical constants which will be used to generate a single random dataset.

```{r, constants}
# ---------- SHO model parameters ----------
Time  <- 5                   # Total time, second
fs <- 1e7                    # Sampling frequency, Hz
f0 <- 33553                  # Resonance frequency, Hz
Q_vec <- c(1, 10, 100, 500)  # Quality factors, unitless
k  <- 0.172                  # Cantilever stiffness, N/m
Kb <- 1.381e-23              # Boltzmann's constant, (m2*kg)/(s2*K)
Temp <- 298                  # Temperature, K
Const <- 1e30                # unit conversion, 1 m2 = 1e30 fm2
Aw <- 19000/Const            # White noise psd, m2/Hz 
```

Then we set the frequency domain as $f_0 \pm f_0/\sqrt{2}$, i.e.,

```{r, freq_domain}
f_lb <- f0 - f0/sqrt(2) # frequency lower bound
f_ub <- f0 + f0/sqrt(2) # frequency upper bound
fseq <- seq(from = f_lb, to = f_ub, by = 1/Time) # frequency domain, Hz
```

By the result of Theorem 1, we can simulate the periodogram values and smooth them by binning with bin size to be 100.

```{r, sim_periodogram}
bin_size <- 100
# create a function to wrap the simualtion routine
sim_period <- function(fseq, f0, fs, Q, k, Kb, Temp, 
  Aw, unit_coversion = FALSE, bin_size = bin_size) {
  # analytic psd values, unit fm2/Hz
  psd <- psdSHO(fseq, f0, Q, k, Kb, Temp, unit_conversion = FALSE) + Aw
  # number of frequencies
  nf <- length(fseq) 
  # simulate exponential random variables
  sim_exp <- rexp(nf, rate = 1)
  # empirical psd (periodogram values)
  Y <- sim_exp * psd * fs
  # smoothed empirical psd (by binning)
  Ybar <- binning(Y, bin_size = bin_size)
  return(Ybar)
}
# frequency domain sequence after binning
fbar <- binning(fseq, bin_size = bin_size)
```

Finally we can plot the smoothed periodogram and superimpose the analytic PSD in one figure (on log-log scale) for $Q = 1, 10, 100, 500$ respectively.

```{r, psd_fig_cap, echo = FALSE}
caption <- rep(NA, length(Q_vec))
for(ii in 1:length(Q_vec)) {
  caption[ii] <- paste0("Empirical smoothed periodogram v.s. analytic PSD (Q = ", Q_vec[ii], ").")
}
```

```{r, psd, fig.cap = caption}
for(ii in 1:length(Q_vec)) {
  plot(x = fbar, y = sim_period(fseq, f0, fs, Q_vec[ii], k, Kb, Temp, 
    Aw, FALSE, bin_size)/fs, 
    xlab = "frequency (Hz)", ylab = expression(paste("PSD (", m^2/Hz, ")")),
    type = "l", lwd = 0.3, log = "xy")
  lines(x = fbar, y = psdSHO(fbar, f0, Q_vec[ii], k, Kb, Temp, FALSE), col = "red")
  legend("topright",
    legend = c("Empirical", "Analytic"), 
    col = c("black", "red"),
    bty = "n", # no box around the legend
    cex = 0.8, # size of the text,
    lwd = 1
  )
}
```

As we can see from Figure \ref{fig:psd1} ~ \ref{fig:psd4}, the simulated periodogram basically matches up with the analytic PSD, which ensures that our simulation of the periodogram by using Theorem 1 does its job.

# Check the MLE estimation/optimization is correct.

## Does `optim` converge?

```{r, check_mle_cap, echo = FALSE}
caption_mle <- rep(NA, length(Q_vec))
for(ii in 1:length(Q_vec)) {
  Q <- Q_vec[ii]
  gamma <- f0*Q
  sig2 <- Kb*Temp/(k*pi*f0*Q)
  Rw <- Aw/sig2
  caption_mle[ii] <- paste0("Optim check when Q = ", Q, ". The true parameter vector is ", 
    "f0 = ", f0, 
    ", gamma = ", gamma,
    ", Rw = ", format(round(Rw, 2), nsmall = 2))
}
```

We can use `optimCheck` to check the "projection plot" of each parameter to see if the minimization of negative log-likelihood works. If we set the initial parameter values to their true values (with some small random noise added), the optimization usually works very well for $Q = 1, 10$, as shown in Figure \ref{fig:check_mle_optim1} ~ \ref{fig:check_mle_optim2}. But for $Q = 100, 500$, the estimation of $\gamma = f_0 \cdot Q$ may not always converge to the minimum, see Figure \ref{fig:check_mle_optim3} ~ \ref{fig:check_mle_optim4}.

We should notice that if the initial parameter values supplied to `optim` are far from their true values, the optimization usually fail to converge (for any $Q$).

```{r, check_mle_init}
# set the initial parameter values for each Q
phi_list <- lapply(1:length(Q_vec), function(ii) {
  Q <- Q_vec[ii]
  sig2 <- Kb*Temp/(k*pi*f0*Q) # variance, unit: m2/Hz
  Rw <- Aw/sig2 # re-parameterization, note we input Aw with unit fm2/Hz
  phi <- c(f0 + rnorm(1, 0, sqrt(f0)), 
    f0*Q + rnorm(1, 0, sqrt(f0*Q)), 
    Rw + rnorm(1, 0, Rw/10)) 
  # optimCheck would fail if we adopt a purely random initial phi
  # phi <- runif(3, min = 0, max = 1e5)
})
```

```{r check_mle_optim, fig.cap = caption_mle}
# method <- "mle"
# check the optimization process for each Q
for(ii in 1:length(Q_vec)) {
  Q <- Q_vec[ii]
  # ---------- setup ----------
  # number of frequencies
  nf <- length(fseq) 
  # analytic psd values, unit fm2/Hz
  psd <- psdSHO(fseq, f0, Q, k, Kb, Temp, unit_conversion = FALSE) + Aw
  # simulate exponential random variables
  sim_exp <- rexp(nf, rate = 1)
  # empirical psd (periodogram values)
  Y <- sim_exp * psd * fs
  # TMB model
  obj <- TMB::MakeADFun(data = list(model_name = "SHOWFit",
                                        method = "MLE_nlp",
                                        f = matrix(fseq),
                                        Y = matrix(Y),
                                        fs = fs),
                            parameters = list(phi = matrix(0, 3, 1)),
                            silent = TRUE, DLL = "realPSD_TMBExports")
  # optimization
  opt <- optim(par = phi_list[[ii]], fn = obj$fn, gr = obj$gr, 
    control = list(maxit = 1000))
  # check optim
  optim_proj(fun = obj$fn, xsol = opt$par, maximize = FALSE,
    xnames = c("f0", "gamma", "Rw"))
}
```


