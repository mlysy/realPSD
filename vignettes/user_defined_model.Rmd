---
title: "**realPSD**: How to define your own model in C++"
author: "Martin Lysy, Feiyu Zhu"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: yes
vignette: >
  %\VignetteIndexEntry{realPSD How to define your own model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

\newcommand{\bm}[1]{\boldsymbol{#1}}
\newcommand{\tx}[1]{\textrm{#1}}
\newcommand{\XX}{{\bm{X}}}
\newcommand{\YY}{{\bm{Y}}}
\newcommand{\ZZ}{{\bm{Z}}}
\newcommand{\tth}{{\bm{\theta}}}
\newcommand{\pph}{{\bm{\varphi}}}
\newcommand{\aal}{{\bm{\alpha}}}
\newcommand{\bbe}{{\bm{\beta}}}
\newcommand{\s}{\sigma}
\newcommand{\f}{f}
\newcommand{\ud}{\mathrm{d}}
\newcommand{\psd}{\operatorname{\mathcal S}}
\newcommand{\cov}{\operatorname{cov}}
\newcommand{\var}{\operatorname{var}}
\newcommand{\acf}{\operatorname{\gamma}}
\newcommand{\carfima}{\operatorname{CARFIMA}}
\newcommand{\rv}[3]{#2_{#1},\ldots,#2_{#3}}
\newcommand{\fs}{\f_s}
\newcommand{\kbt}{k_BT}
\newcommand{\Aw}{A_{\tx{w}}}
\newcommand{\Rw}{R_{\tx{w}}}

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
# link to packages
pkg_link <- function(pkg, link) {
  if(link == "github") {
    link <- paste0("https://github.com/mlysy/", pkg)
  } else if(link == "cran") {
    link <- paste0("https://CRAN.R-project.org/package=", pkg)
  }
  paste0("[**", pkg, "**](", link, ")")
}
cran_link <- function(pkg) pkg_link(pkg, "cran")
github_link <- function(pkg) pkg_link(pkg, "github")
```

## Write your own model in C++ using **realPSD**

**realPSD** allows users to easily implement their own model in C++ using **TMB** interface to R. **TMB** (Template Model Builder) is an R package for fitting statistical latent variable models to data, which is extensively documented [here](https://github.com/kaskr/adcomp/wiki/Documentation). **TMB** uses the C++ library for linear algebra [**Eigen**](http://eigen.tuxfamily.org/index.php?title=Main_Page) which is extensively documented [here](http://eigen.tuxfamily.org/dox/). We should be familiar with the basic data types provided by **Eigen** and an entry-level understanding of how to use **TMB** in R.

For any parametric PSD of the form 
$$
\psd(\f,\tth) = \s^2 \cdot U(\f, \pph),
$$
where $\tth = (\s, \pph)$ are the parameters and $\f$ represents a sequence of observations (frequency points), it will be easy for users to define their own model class definition and supply it to TMB for later model fitting.

Now let us see an example.

## An example: Fractional Ornstein-Uhlenbeck Model

Here we implement a fractional OU model to make the above steps more concrete. Recall that the fOU model is expressed as
$$
\ud X(t) = -\gamma X(t)\, \ud t + \tau \, \ud B_t^H,
$$
where $\gamma, \tau > 0$ and $B_t^H$ is fractional Brownian motion with Hurst parameter $0 < H < 1$.  The PSD for this model is
\begin{equation}
\label{eq:fcar}
\psd(\f, \tth) = \sigma^2 \times \frac{|\f|^{1-2H}}{\f^2 + \gamma^2},
\end{equation}
where $\pph = (H, \gamma)$ and $\sigma^2 = \tau^2 \cdot \Gamma(2H+1)\sin(\pi H)/(2\pi)$.

We first define our fOU model in a C++ header file `fou.hpp`. To avoid potential scope conflict, we enclose the class definition within a user-defined namespace. Since **TMB** macros `DATA_MATRIX()`, etc. don't work inside class member functions, to allow users to decide and change input arguments to the model, we define an external constructor `make_Ufun(int N, objective_function<Type>* obj)` at the very end.

```{Rcpp, fou, eval = FALSE}
/// @file fou.cpp
///
/// @brief fractional OU model, passing data to TMB
namespace fou {
  /// create `matrix<Type>` of zeros as a helper function
  ///
  /// @param[in] n Integer number of rows.
  /// @param[in] p Integer number of columns.
  /// @return A `matrix<Type>` of size `n x p` initialized with zeros.
  template<class Type>
  matrix<Type> zero_matrix(int n, int p) {
    matrix<Type> out(n,p);
    out.setZero();
    return out;
  }

  /// A template class for fractional OU model
  template <class Type>
  class UFun {
  private:
    //typedefs
    /// Typedef equivalent to `matrix<Type>`.
    typedef Eigen::Matrix<Type, Eigen::Dynamic, Eigen::Dynamic> MatrixXd_t;
    /// Typedef equivalent to `Ref <matrix<Type> >`.
    typedef Eigen::Ref <MatrixXd_t> RefMatrix_t;
    /// Typedef equivalent to `const Ref <const matrix<Type> >`.
    typedef const Eigen::Ref <const MatrixXd_t> cRefMatrix_t;
    // internal variables
    int N_; ///> problem dimensions
    matrix<Type> f_; ///>column vector of frequencies
    matrix<Type> f2_; ///> column vector of squared frequencies.
  public:
    /// Constructor.
    UFun(int N);
    /// Set frequency vector.
    void set_f(cRefMatrix_t& f);
    /// Evaluate the normalized PSD.
    void eval(RefMatrix_t U, cRefMatrix_t& phi);
  };

  template<class Type>
  inline UFun<Type>::UFun(int N) {
    N_ = N;
    f_ = zero_matrix<Type>(N_, 1);
    f2_ = zero_matrix<Type>(N_,1);
  }

  template<class Type>
  inline void UFun<Type>::set_f(cRefMatrix_t& f) {
    N_ = f.size();
    f_ = zero_matrix<Type>(N_,1);
    f_ = f;
    f2_ = zero_matrix<Type>(N_,1);
    f2_ = f.cwiseProduct(f);
    return;
  }

  /// Parameters are: `phi = (H, gamma)`
  // psd = |f|^(1-2H) / (f^2 + gamma^2)
  template <class Type>
  inline void UFun<Type>::eval(RefMatrix_t U, cRefMatrix_t& phi) {
    U = f2_.array() + phi(1,0) * phi(1,0);
    U = (f_.array().abs()).pow(1-Type(2.0)*phi(0,0)) / U.array(); // use ArrayBase::pow() and ::abs() functions
    return;
  }

  #undef TMB_OBJECTIVE_PTR
  #define TMB_OBJECTIVE_PTR obj

  template<class Type>
  UFun<Type> make_Ufun(int N, objective_function<Type>* obj) {
    return UFun<Type>(N);
  }

  #undef TMB_OBJECTIVE_PTR
  #define TMB_OBJECTIVE_PTR this
} // end namespace fou
```



We can compile our template class `fou.hpp` and supply it to TMB in an R session on-the-fly.

```{r, fou_test_setup, eval = FALSE}
# test generic fou model header created by make_psd_model
require(realPSD)
require(whisker)
require(TMB)

# standalone == TRUE, compile on-the-fly mode
make_psd_model(
  name = "fou",
  header = "fou.hpp",
  class = "fou::UFun",
  ctor = "fou::make_Ufun",
  include = "realPSD/FitMethods.hpp",
  method = "realPSD::FitMethods",
  standalone = TRUE,
  path = "fou_Generics.cpp"
)

compile("fou_Generics.cpp", PKG_CXXFLAGS = paste0("-I", system.file("include", package = "realPSD")))
dyn.load(dynlib("fou_Generics"))
model <- "fou_Generics"
```

Then we can test the model by using the following unit tests:

```{r, fou_test_on_the_fly, eval = FALSE}
require(testthat)
# helper function: calculate the psd in R
fou_psd_r <- function(f, phi) {
 psd <- abs(f)^(1-2*phi[1]) / (f^2 + phi[2]^2)
}

context("Test: fractional OU model")

test_that("The UFun returned by TMB (C++) is the same as that given by R", {
  ntests <- 20
  for(ii in 1:ntests) {
    N <- sample(10:20, 1)
    f <- matrix(runif(N, 0, 2*N))
    phi <- matrix(c(runif(1), rexp(1))) # phi = c(H, gamma) where 0 < H < 1, gamma > 0
    obj <- MakeADFun(data = list(f = f, method = "UFun"),
                 parameters = list(phi = matrix(c(runif(1), rexp(1)))),
                 DLL = model, silent = TRUE)
    psd_tmb <- obj$simulate(c(phi))$U
    psd_r <- fou_psd_r(f, phi)
    expect_equal(psd_tmb, psd_r)
  }
})

# helpfer function
mle_tau_r <- function(f, Y, phi, ufun, fs) {
  U <- fs * ufun(f, phi)
  mean(Y/U)
}
sim_Y <- function(n) rchisq(n, df = 2)
# normalized PSD
# phi = c(H, gamma)
fou_ufun <- function(f, phi) {
  abs(f)^(1-2*phi[1]) / (f^2 + phi[2]^2)
}
# simulate the sampling freq
sim_fs <- function() sample(10:1000, size = 1)

test_that("sigma^2 returned by TMB (C++) is the same as that given by R", {
  ntests <- 20
  for(ii in 1:ntests) {
    N <- sample(50:100, 1)
    f <- matrix(runif(N, 0, 2*N))
    fs <- sim_fs()
    phi <- matrix(c(runif(1), rexp(1))) 
    Y <- matrix(sim_Y(N))
    # TMB obj
    obj <- MakeADFun(
      data = list(f = f, Y = Y, fs = fs, method = "MLE_tau"), 
      parameters = list(phi = matrix(0.5, 2)), 
      DLL = model, silent = TRUE
    )
    # define mle_tau from TMB
    mle_tau_tmb <- function(phi) obj$fn(phi)
    # comparison
    tau_tmb <- mle_tau_tmb(phi)
    tau_r <- mle_tau_r(f, Y, phi, ufun = fou_ufun, fs)
    expect_equal(tau_tmb, tau_r)
  }
})
```
Please feel free to try to design your own model and fit its parameters by using the three different methods (MLE, NLS, LP) provided by **realPSD**. Have fun!
