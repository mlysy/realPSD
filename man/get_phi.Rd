% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/show_fit.R
\name{get_phi}
\alias{get_phi}
\title{Convert SHOW parameterization to natural parameterization.}
\usage{
get_phi(par, method = c("MLE", "NLS", "LP"), Temp, const)
}
\arguments{
\item{par}{SHOW parameters \verb{(k, f0, Q, Sw)}.}

\item{method}{Fitting method}

\item{Temp}{Temperature constant}

\item{const}{Normalizing constant applied to both PSD inputs and \code{tau} in each fitting method (see 'Notes').}
}
\value{
Numeric vector with elements that you can plug back into TMB methods \code{LP_nll}, \code{NLS_nll}, or \code{MLE_nll}.
}
\description{
Convert SHOW parameterization to natural parameterization.
}
\details{
Since we want the result in the original basis, let's compute the hessian numerically.  That is, if \code{par_hat} is the mode and let's say we're doing LP, the hessian is obtained with\preformatted{# assume we are inside show_fit_*,
# such that `bin_size`, `constZ`, `Zbar`, etc. have been defined
# (and properly normalized).
numDeriv::hessian(
            x = par_hat,
            func = function(par) \{
              phi_zeta <- get_phi(par, method = "LP", const = constZ)
              obj <- TMB::MakeADFun(data = list(
                                      model = "SHOW_log",
                                      method = "LP_nll",
                                      fbar = as.matrix(fbar),
                                      Zbar = as.matrix(Zbar - constZ),
                                      fs = fs/exp(bin_const(bin_size))),
                                    parameters = list(phi = as.matrix(c(0,0,0)),
                                                      zeta = 0),
                                    silent = TRUE, DLL = "realPSD_TMBExports")
              obj$fn(phi_zeta)
            \})

}
}
\note{
\itemize{
\item \code{\link[=show_fit_mle]{show_fit_mle()}} and \code{\link[=show_fit_nls]{show_fit_nls()}} normalize the inputs to avoid numerical overflow.  This should be done here as well, which means there's a conversion factor to apply to \code{tau}.  My suggestion is to add the standard error calculation directly to the \verb{show_fit_*} functions.
\item \verb{show_fit_*} have something called \code{constZ} or \code{constY} which is used to rescale the PSD inputs to avoid numerical overflow.  The scale factor \code{tau} gets corrected accordingly, and the same thing should be done here as well with the parameter \code{const}.
}
}
