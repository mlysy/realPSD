<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Martin Lysy, Feiyu Zhu" />

<meta name="date" content="2021-01-08" />

<title>realPSD: Theory and Design Principles</title>

<script src="data:application/javascript;base64,Ly8gUGFuZG9jIDIuOSBhZGRzIGF0dHJpYnV0ZXMgb24gYm90aCBoZWFkZXIgYW5kIGRpdi4gV2UgcmVtb3ZlIHRoZSBmb3JtZXIgKHRvCi8vIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3Igb2YgUGFuZG9jIDwgMi44KS4KZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKGUpIHsKICB2YXIgaHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCJkaXYuc2VjdGlvbltjbGFzcyo9J2xldmVsJ10gPiA6Zmlyc3QtY2hpbGQiKTsKICB2YXIgaSwgaCwgYTsKICBmb3IgKGkgPSAwOyBpIDwgaHMubGVuZ3RoOyBpKyspIHsKICAgIGggPSBoc1tpXTsKICAgIGlmICghL15oWzEtNl0kL2kudGVzdChoLnRhZ05hbWUpKSBjb250aW51ZTsgIC8vIGl0IHNob3VsZCBiZSBhIGhlYWRlciBoMS1oNgogICAgYSA9IGguYXR0cmlidXRlczsKICAgIHdoaWxlIChhLmxlbmd0aCA+IDApIGgucmVtb3ZlQXR0cmlidXRlKGFbMF0ubmFtZSk7CiAgfQp9KTsK"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<link rel="stylesheet" href="data:text/css,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" type="text/css" />




</head>

<body>




<h1 class="title toc-ignore"><strong>realPSD</strong>: Theory and Design Principles</h1>
<h4 class="author">Martin Lysy, Feiyu Zhu</h4>
<h4 class="date">2021-01-08</h4>


<div id="TOC">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#methods">Methods</a>
<ul>
<li><a href="#maximum-likelihood">Maximum Likelihood</a></li>
<li><a href="#nonlinear-least-squares">Nonlinear Least-Squares</a></li>
<li><a href="#log-periodogram-variance-stabilized-least-squares">Log-Periodogram (Variance-Stabilized Least-Squares)</a></li>
<li><a href="#variance-estimators">Variance Estimators</a></li>
<li><a href="#model-residuals">Model Residuals</a></li>
<li><a href="#scaling">Scaling</a></li>
<li><a href="#median-binning">Median Binning</a></li>
</ul></li>
<li><a href="#examples">Examples</a>
<ul>
<li><a href="#simple-harmonic-oscillator-with-noise-floor">Simple Harmonic Oscillator with Noise Floor</a></li>
<li><a href="#simple-harmonic-oscillator-with-1f-noise">Simple Harmonic Oscillator with <span class="math inline">\(1/f\)</span> Noise</a></li>
<li><a href="#fractional-ornstein-uhlenbeck-model">Fractional Ornstein-Uhlenbeck Model</a></li>
<li><a href="#carfima-models">CARFIMA Models</a></li>
</ul></li>
<li><a href="#interfacing-with-tmb">Interfacing with <strong>TMB</strong></a>
<ul>
<li><a href="#external-constructor-for-user-defined-model-object">External Constructor for User-defined Model Object</a></li>
<li><a href="#compile-on-the-fly">Compile-on-the-fly</a></li>
<li><a href="#wrap-the-model-object-by-r6-class">Wrap the Model Object by R6 Class</a></li>
<li><a href="#list-of-built-in-fitting-methods">List of Built-in Fitting Methods</a></li>
</ul></li>
</ul>
</div>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<p>This vignette explains the theory behind the built-in estimation methods provided by <strong>realPSD</strong> and also discusses some technical details in designing <strong>realPSD</strong>. This package is essentially a port of <a href="https://github.com/mlysy/realSHO"><strong>realSHO</strong></a> whic is based on <a href="https://www.mathworks.com/products/matlab.html">MATLAB</a>, but with the option of freely adding one’s own models and carrying out accurate and efficient gradient calculations. The interface is through the R <a href="https://CRAN.R-project.org/package=TMB"><strong>TMB</strong></a> package, which uses <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a> (AD) to enable gradient-based optimization algorithms to efficiently perform parameter estimation.</p>
<p>For a complete exposition of the theory (with theorems and proofs) as well as the real-world application background, please check out this <a href>preprint</a>.</p>
<div id="overview" class="section level1">
<h1>Overview</h1>
<p>Let <span class="math inline">\(X(t)\)</span> denote a continuous time mean-zero stationary process with autocorrelation <span class="math inline">\(\operatorname{\gamma}(t) = \operatorname{cov}(X_s, X_{s+t})\)</span>. with power spectral density (PSD) defined via the inverse Fourier transform relation <span class="math display">\[
\operatorname{\gamma}(t) = \int_{-\infty}^\infty e^{-2\pi i tf} \operatorname{\mathcal S}(f) \, \mathrm{d}f,
\]</span> where <span class="math inline">\(f\in \mathbb R\)</span> is the frequency in Hertz (Hz). The <strong>realPSD</strong> package provides tools for estimation of parametric PSDs of the form <span class="math display">\[
\operatorname{\mathcal S}(f,{\boldsymbol{\theta}}) = \sigma^2 \cdot U(f, {\boldsymbol{\varphi}}),
\]</span> where the PSD parameters are <span class="math inline">\({\boldsymbol{\theta}}= (\sigma, {\boldsymbol{\varphi}})\)</span>. The data <span class="math inline">\({\boldsymbol{X}}= (X_{0},\ldots,X_{N-1})\)</span> consist of discrete observations of <span class="math inline">\(X(t)\)</span> recorded at sampling frequency <span class="math inline">\(f_s\)</span>, such that <span class="math inline">\(X_n = X(n/f_s)\)</span>.</p>
<p>Traditional theory of time series always assumes that the time interval of the collected data <span class="math inline">\({\boldsymbol{X}}= (X_{0},\ldots,X_{N-1})\)</span> is fixed and the asymptotics of the estimators are all about the situation when <span class="math inline">\(N \to \infty\)</span>. However, in many modern scientific experiments, for example recordings collected by an <a href="https://en.wikipedia.org/wiki/Atomic_force_microscopy">Atomic Force Microscope</a>, <strong>high-throughput (HTP) data</strong> are very common. That is, we can let both <span class="math inline">\(f_s\to \infty\)</span> and <span class="math inline">\(N \to \infty\)</span>. In this situation, traditional theory fails. To overcome this, traditional techniques have to be generalized. <strong>realPSD</strong> was built as a robust and efficient toolbox to realize this. That being said, you can still use <strong>realPSD</strong> for traditional settings, for example to fit an Ornstein-Uhlenbeck (OU) model, as we’ve already shown in the <a href="http://htmlpreview.github.io/?https://github.com/mlysy/realPSD/blob/devel-ferris-prerelease/doc/realPSD-quicktut.html">quick tutorial</a>.</p>
<!-- This interface is written in Python, and uses [automatic differentiation](https://en.wikipedia.org/wiki/Automatic_differentiation) (AD) to use gradient-based optimization algorithms to efficiently perform parameter estimation. -->
<!-- ~~Currently the interface is through the R [**TMB**](https://CRAN.R-project.org/package=TMB) package, which makes the underlying C++ code difficult to interface from a different language (e.g., Python, Matlab).  A later step is to create a self-contained C++ library relying only on [**CppAD**](https://coin-or.github.io/CppAD/doc/cppad.htm), the C++ automated differentiation (AD) library on top of which **TMB** is built.~~ -->
</div>
<div id="methods" class="section level1">
<h1>Methods</h1>
<p><strong>realPSD</strong> provides three different methods for parameter estimation outlined below. For each method, estimation is via optimization over a function of <span class="math inline">\({\boldsymbol{\varphi}}\)</span>, with the fitted value of <span class="math inline">\(\sigma\)</span> being profiled out. In all cases the estimators are built on the discrete Fourier transform of the data, <span class="math inline">\({\boldsymbol{Y}}= (Y_{1},\ldots,Y_{K})\)</span>, where <span class="math inline">\(N = 2K + 1\)</span> and</p>
<p><span class="math display">\[
Y_k = \frac{1}{N f_s} \left\vert \sum_{n=0}^{N-1} e^{-2\pi i k n} X_n\right\vert^2.
\]</span></p>
<p><strong>realPSD</strong> provides a function <code>periodogram()</code> to calculate this <span class="math inline">\(Y_k\)</span>. Note that the returned periodogram is just one-sided. For more details about how <span class="math inline">\(Y_k\)</span> is related to the Whittle-type loglikelihood in the MLE, please refer to Proposition 1 and the discussion thereafter in this <a href>preprint</a>.</p>
<p>All the following methods are provided in the C++ header files in <strong>realPSD</strong>, please check out the source code of <code>FitMethods.hpp</code>, <code>MLEFit.hpp</code>, <code>NLSFit.hpp</code> and <code>LPFit.hpp</code> etc.</p>
<div id="maximum-likelihood" class="section level2">
<h2>Maximum Likelihood</h2>
<p>The maximum likelihood estimator is obtained by maximizing the so-called Whittle loglikelihood function, <span class="math display">\[\begin{equation}
\label{eq:mle}
\ell_W({\boldsymbol{\theta}}\mid {\boldsymbol{Y}}) = - \sum_{k=1}^K\left(\frac{Y_k}{\operatorname{\mathcal S}_k({\boldsymbol{\theta}})} + \log \operatorname{\mathcal S}_k({\boldsymbol{\theta}})\right),
\end{equation}\]</span> where where <span class="math inline">\(\operatorname{\mathcal S}_k({\boldsymbol{\theta}}) = \operatorname{\mathcal S}(f_k, {\boldsymbol{\theta}})\)</span> and <span class="math inline">\(f_k = \tfrac k N f_s\)</span>. Note that for given <span class="math inline">\({\boldsymbol{\varphi}}\)</span>, the value of <span class="math inline">\(\sigma^2\)</span> maximizing \eqref{eq:mle} is <span class="math display">\[
\hat \sigma^2({\boldsymbol{\varphi}}) = \frac 1 K \sum_{k=1}^K \frac{Y_k}{U_k({\boldsymbol{\varphi}})},
\]</span> where <span class="math inline">\(U_k({\boldsymbol{\varphi}}) = U(f_k, {\boldsymbol{\varphi}})\)</span>. Therefore, upon maximizing the profile likelihood <span class="math display">\[
\begin{aligned}
\ell_{W,\textrm{prof}}({\boldsymbol{\varphi}}\mid {\boldsymbol{Y}}) &amp; = \ell_W({\boldsymbol{\varphi}}, \hat \sigma({\boldsymbol{\varphi}}) \mid {\boldsymbol{Y}}) \\
&amp; = - K (1 + \log \hat \sigma^2({\boldsymbol{\varphi}})) - \sum_{k=1}^K \log U_k({\boldsymbol{\varphi}}),
\end{aligned}
\]</span> we obtain the MLE <span class="math inline">\(\hat {\boldsymbol{\theta}}= (\hat {\boldsymbol{\varphi}}, \hat \sigma(\hat {\boldsymbol{\varphi}}))\)</span>.</p>
</div>
<div id="nonlinear-least-squares" class="section level2">
<h2>Nonlinear Least-Squares</h2>
<p>In many situations with high-throughput (HTP) data, <span class="math inline">\(K\)</span> is very large, such that calculating the MLE becomes very computationally intensive. An approximation to the MLE involves binning the periodogram ordinates. That is, let <span class="math inline">\(K = B \cdot N_B\)</span>, and <span class="math display">\[
\bar Y_m = \frac 1 B \sum_{k \in I_m} Y_k, \qquad I_m = \{k \in \mathbb N: (m-1)B &lt; k \le mB\}.
\]</span> Then the nonlinear least-squares (NLS) estimator maximizes the objective function <span class="math display">\[\begin{equation}
\label{eq:nls}
Q_{\textrm{NLS}}({\boldsymbol{\theta}}) = - \sum_{m=1}^{N_B} \big(\bar Y_m - \bar{\operatorname{\mathcal S}}_m({\boldsymbol{\theta}})\big)^2,
\end{equation}\]</span> where <span class="math inline">\(\bar{\operatorname{\mathcal S}}_m({\boldsymbol{\theta}}) = \operatorname{\mathcal S}(\bar f_m, {\boldsymbol{\theta}})\)</span> and <span class="math inline">\(\bar f_m = \tfrac 1 B \sum_{k\in I_m} f_k\)</span>. For given <span class="math inline">\({\boldsymbol{\varphi}}\)</span>, the value of <span class="math inline">\(\sigma^2\)</span> maximizing \eqref{eq:nls} is <span class="math display">\[
\hat \sigma^2({\boldsymbol{\varphi}}) = \frac{\sum_{m=1}^{N_B} \bar{U}_m({\boldsymbol{\varphi}}) \bar Y_m }{\sum_{m=1}^{N_B} \bar{U}_m({\boldsymbol{\varphi}})^2},
\]</span> where <span class="math inline">\(\bar{U}_m({\boldsymbol{\varphi}}) = U(\bar f_m, {\boldsymbol{\varphi}})\)</span>. Therefore, upon maximizing the objective function <span class="math display">\[
Q_{\textrm{NLS},\textrm{prof}}({\boldsymbol{\varphi}}) = -\sum_{m=1}^{N_B} \big(\bar Y_m - \hat \sigma^2({\boldsymbol{\varphi}}) \cdot \bar{U}_m({\boldsymbol{\varphi}})\big)^2,
\]</span> we obtain the maximum of \eqref{eq:nls} via <span class="math inline">\(\hat {\boldsymbol{\theta}}= (\hat {\boldsymbol{\varphi}}, \hat \sigma(\hat {\boldsymbol{\varphi}}))\)</span>.</p>
</div>
<div id="log-periodogram-variance-stabilized-least-squares" class="section level2">
<h2>Log-Periodogram (Variance-Stabilized Least-Squares)</h2>
<p>Let <span class="math inline">\(Z_m = \log(\bar Y_m)\)</span>. Then the log-periodogram (LP) estimator maximizes the approximate loglikelihood <span class="math display">\[\begin{equation}
\label{eq:lp}
\ell_{\textrm{LP}}({\boldsymbol{\theta}}\mid {\boldsymbol{Y}}) = -\frac B 2 \sum_{m=1}^{N_B} \big(Z_m + C_B - \log \bar{\operatorname{\mathcal S}}_m({\boldsymbol{\theta}})\big)^2,
\end{equation}\]</span> where <span class="math inline">\(C_B = \log B - \psi(B)\)</span> and <span class="math inline">\(\psi(x)\)</span> is the <a href="https://en.wikipedia.org/wiki/Digamma_function">digamma function</a>. For given <span class="math inline">\({\boldsymbol{\varphi}}\)</span>, the value of <span class="math inline">\(\sigma^2\)</span> maximizing \eqref{eq:lp} is <span class="math display">\[
\hat \sigma^2({\boldsymbol{\varphi}}) = \exp\left\{\hat \zeta({\boldsymbol{\varphi}}) + C_B\right\}, \qquad \hat \zeta({\boldsymbol{\varphi}}) = \frac{1}{N_B} \sum_{m=1}^{N_B} Z_m - \log \bar{U}_m({\boldsymbol{\varphi}}),
\]</span> such that upon maximizing <span class="math display">\[
\ell_{\textrm{LP},\textrm{prof}}({\boldsymbol{\varphi}}\mid {\boldsymbol{Y}}) = - \sum_{m=1}^{N_B} \big(Z_m - \hat \zeta({\boldsymbol{\varphi}}) - \log \bar U_m({\boldsymbol{\varphi}})\big)^2
\]</span> we obtain the maximum of \eqref{eq:lp} via <span class="math inline">\(\hat {\boldsymbol{\theta}}= (\hat {\boldsymbol{\varphi}}, \hat \sigma(\hat {\boldsymbol{\varphi}}))\)</span>.</p>
</div>
<div id="variance-estimators" class="section level2">
<h2>Variance Estimators</h2>
<p>The MLE loglikelihood \eqref{eq:mle} can be used to calculate the observed Fisher information, which in turn can be used to produce the variance estimates <span class="math display">\[
\widehat{\operatorname{var}}(\hat {\boldsymbol{\theta}}_{\textrm{MLE}}) = -\left[\frac{\partial^2}{\partial {\boldsymbol{\theta}}^2} \ell_W(\hat{\boldsymbol{\theta}}_{\textrm{MLE}} \mid {\boldsymbol{Y}})\right]^{-1}.
\]</span> It turns out that the same holds for the LP loglikelihood \eqref{eq:lp} up to a small inflation factor: <span class="math display">\[
\widehat{\operatorname{var}}(\hat {\boldsymbol{\theta}}_{\textrm{LP}}) = D_B \times -\left[\frac{\partial^2}{\partial {\boldsymbol{\theta}}^2} \ell_{\textrm{LP}}(\hat{\boldsymbol{\theta}}_{\textrm{LP}} \mid {\boldsymbol{Y}})\right]^{-1},
\]</span> where <span class="math inline">\(D_B = B \psi&#39;(B)\)</span>. Note that <span class="math inline">\(D_{10} = 1.05\)</span> and <span class="math inline">\(D_{100} = 1.005\)</span>, such that correcting by <span class="math inline">\(D_B\)</span> has little impact in practice.</p>
<!-- Both the MLE and LP loglikelihoods \\eqref{eq:mle} and \\eqref{eq:lp} can be used to calculate the observed Fisher information, which in turn can be used to produce the variance estimates -->
<!-- $$ -->
<!-- \begin{aligned} -->
<!-- \widehat{\var}(\hat \tth_{\tx{MLE}}) & = -\left[\frac{\partial^2}{\partial \tth^2} \ell_W(\hat\tth_{\tx{MLE}} \mid \YY)\right]^{-1} \\ -->
<!-- \widehat{\var}(\hat \tth_{\tx{LP}}) & = -\left[\frac{\partial^2}{\partial \tth^2} \ell_{\tx{LP}}(\hat\tth_{\tx{LP}} \mid \YY)\right]^{-1}. -->
<!-- \end{aligned} -->
<!-- $$ -->
<p>In contrast to the likelihood-based estimators, the variance of the NLS estimator is defined by the sandwich formula <span class="math display">\[\begin{equation}
\label{eq:sand}
\widehat{\operatorname{var}}(\hat {\boldsymbol{\theta}}_{\textrm{NLS}}) = - \boldsymbol{A}^{-1} \boldsymbol{B} \boldsymbol{A}^{-1},
\end{equation}\]</span> where for <span class="math inline">\(g_m({\boldsymbol{\theta}}) = (\bar Y_m - \bar{\operatorname{\mathcal S}}_m({\boldsymbol{\theta}}))^2\)</span>, we have <span class="math display">\[
\begin{aligned}
\boldsymbol{A} &amp; = \sum_{m=1}^{N_B} \frac{\partial^2}{\partial {\boldsymbol{\theta}}^2} g_m(\hat {\boldsymbol{\theta}}_{\textrm{NLS}}) \\
\boldsymbol{B} &amp; = \sum_{m=1}^{N_B} \left[\frac{\partial}{\partial {\boldsymbol{\theta}}} g_m(\hat {\boldsymbol{\theta}}_{\textrm{NLS}})\right]\left[\frac{\partial}{\partial {\boldsymbol{\theta}}} g_m(\hat {\boldsymbol{\theta}}_{\textrm{NLS}})\right]&#39;.
\end{aligned}
\]</span></p>
</div>
<div id="model-residuals" class="section level2">
<h2>Model Residuals</h2>
<p>Both the NLS and LP (profile) optimization problems can be rewritten as minimizing a sum-of-squares objective function <span class="math display">\[
S({\boldsymbol{\varphi}}) = \sum_{m=1}^{N_B} r_m({\boldsymbol{\varphi}})^2,
\]</span> for which specialized optimization algorithms such as <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Newton_algorithm">Gauss-Newton</a> or <a href="https://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm">Levenberg-Marquardt</a> can be used.</p>
</div>
<div id="scaling" class="section level2">
<h2>Scaling</h2>
<p>For numerical stability, we have found that it is often preferable to express the Whittle likelihood \eqref{eq:mle} as <span class="math display">\[
\ell_W({\boldsymbol{\theta}}\mid {\boldsymbol{Y}}) = - \sum_{k=1}^K\left(\frac{Y_k^{(s)}}{\operatorname{\mathcal S}_k({\boldsymbol{\theta}})/C_s} + \log \operatorname{\mathcal S}_k({\boldsymbol{\theta}})\right),
\]</span> where <span class="math inline">\(Y_k^{(s)} = Y_k/C_s\)</span> and <span class="math inline">\(C_s &gt; 0\)</span> is a scaling factor (e.g., <span class="math inline">\(C_s = K^{-1} \sum_{k=1}^K Y_k\)</span>). In this case, the value of <span class="math inline">\(\sigma^2\)</span> maximing \eqref{eq:mle} for given <span class="math inline">\({\boldsymbol{\varphi}}\)</span> is <span class="math display">\[
\hat \sigma^2({\boldsymbol{\varphi}}) = C_s \cdot \hat \sigma^2_{(s)}({\boldsymbol{\varphi}}), \qquad \hat \sigma^2_{(s)}({\boldsymbol{\varphi}}) = \frac {1} K \sum_{k=1}^K \frac{Y_k^{(s)}}{U_k({\boldsymbol{\varphi}})},
\]</span> and the profile loglikelihood may be expressed as <span class="math display">\[
\ell_{W,\textrm{prof}}({\boldsymbol{\varphi}}\mid {\boldsymbol{Y}}) = - K (1 + \log C_s + \log \hat \sigma_{(s)}^2({\boldsymbol{\varphi}})) - \sum_{k=1}^K \log U_k({\boldsymbol{\varphi}}).
\]</span></p>
<p>Similarly, for the NLS estimator we may maximize the objective function <span class="math display">\[
Q_{\textrm{NLS}}^{(s)}({\boldsymbol{\theta}}) = - \sum_{m=1}^{N_B} \big(\bar Y_m^{(s)} - \bar{\operatorname{\mathcal S}}_m({\boldsymbol{\theta}})/C_s\big)^2,
\]</span> where <span class="math inline">\(\bar Y_m^{(s)} = \bar Y_m / C_s\)</span>. The corresponding profiled function is <span class="math display">\[
Q_{\textrm{NLS},\textrm{prof}}^{(s)}({\boldsymbol{\varphi}}) = -\sum_{m=1}^{N_B} \big(\bar Y_m^{(s)} - \hat \sigma_{(s)}^2({\boldsymbol{\varphi}}) \cdot \bar{U}_m({\boldsymbol{\varphi}})\big)^2,
\]</span> where <span class="math display">\[
\hat \sigma_{(s)}^2({\boldsymbol{\varphi}}) = \frac{\sum_{m=1}^{N_B} \bar{U}_m({\boldsymbol{\varphi}}) \bar Y_m^{(s)} }{\sum_{m=1}^{N_B} \bar{U}_m({\boldsymbol{\varphi}})^2} = \hat \sigma^2({\boldsymbol{\varphi}})/C_s.
\]</span></p>
<p>Scaling is typically not needed for the LP estimator, but for completeness we provide the calculations here. That is, for <span class="math inline">\(Z_m^{(s)} = Z_m - C_s\)</span>, we have <span class="math display">\[
\ell_{\textrm{LP}}({\boldsymbol{\theta}}\mid {\boldsymbol{Y}}) = - \frac B 2 \big(Z_m^{(s)} + C_s + C_B - \log \bar{\operatorname{\mathcal S}}_m({\boldsymbol{\theta}}) \big)^2
\]</span> and <span class="math display">\[
\hat \sigma^2({\boldsymbol{\varphi}}) = \exp\left\{\hat \zeta_{(s)}({\boldsymbol{\varphi}}) + C_s + C_B\right\}, \qquad \hat \zeta_{(s)}({\boldsymbol{\varphi}}) = \frac{1}{N_B} \sum_{m=1}^{N_B} Z_m^{(s)} - \log \bar{U}_m({\boldsymbol{\varphi}}).
\]</span></p>
</div>
<div id="median-binning" class="section level2">
<h2>Median Binning</h2>
<p>The NLS and LP estimators are defined in terms of the bin mean <span class="math inline">\(\bar Y_m\)</span>. To decrease sensitivity to outliers, one might consider the bin median <span class="math inline">\(\tilde Y_m = \operatorname{median}\{Y_k: k \in I_m\}\)</span>. In this case, we have <span class="math display">\[
\begin{aligned}
\lim_{B\to\infty} E[\tilde Y_m] &amp; = \bar{\operatorname{\mathcal S}}_m({\boldsymbol{\theta}}) \cdot \log 2, \\ \lim_{B\to\infty} E[\log \tilde Y_m] &amp; = \log \bar{\operatorname{\mathcal S}}_m({\boldsymbol{\theta}}) + \log \log 2,
\end{aligned}
\]</span> such that we may try to maximize the objective functions <span class="math display">\[
\begin{aligned}
\tilde Q^{(s)}_{\textrm{NLS}}({\boldsymbol{\theta}}) &amp; = - \sum_{m=1}^{N_B}\big(\tilde Y_m^{(s)} - (\log 2/C_s) \cdot \bar{\operatorname{\mathcal S}}_m({\boldsymbol{\theta}})\big)^2 \\
\tilde Q^{(s)}_{\textrm{LP}}({\boldsymbol{\theta}}) &amp; = - \sum_{m=1}^{N_B} \big(\tilde Z_m^{(s)} + C_s - \log \log 2 - \log \bar{\operatorname{\mathcal S}}_m({\boldsymbol{\theta}})\big)^2.
\end{aligned}
\]</span> Note here that neither the LP nor NLS estimators are asympotically loglikelihoods, such that variance estimators should use the sandwich formula \eqref{eq:sand}.</p>
</div>
</div>
<div id="examples" class="section level1">
<h1>Examples</h1>
<div id="simple-harmonic-oscillator-with-noise-floor" class="section level2">
<h2>Simple Harmonic Oscillator with Noise Floor</h2>
<p>The SHOW model is given by <span class="math display">\[\begin{equation}
\label{eq:show}
\begin{aligned}
\operatorname{\mathcal S}(f, {\boldsymbol{\theta}}) &amp; = A_{\textrm{w}}+ \frac{k_BT/(k \cdot \pi f_0 Q)}{[(f/f_0)^2-1]^2 + [f/(f_0Q)]^2} \\
&amp; = \sigma^2 \times \left\{R_{\textrm{w}}+ \frac{1}{[(f/f_0)^2-1]^2 + [f/\gamma]^2}\right\},
\end{aligned}
\end{equation}\]</span> where <span class="math inline">\(\sigma^2 = k_BT/(k\cdot \pi f_0Q)\)</span>, <span class="math inline">\(R_{\textrm{w}}= A_{\textrm{w}}/\sigma^2\)</span>, <span class="math inline">\(\gamma = f_0Q\)</span>, and <span class="math inline">\({\boldsymbol{\varphi}}= (f_0, \gamma, R_{\textrm{w}})\)</span>.</p>
<p>This is a built-in model in <strong>realPSD</strong> with three different parameterizations:</p>
<ul>
<li>natural parameterization <span class="math inline">\({\boldsymbol{\theta}}= (f_0, \gamma, R_{\textrm{w}})\)</span> which is the straightforward parameter vector users want to look at;</li>
<li>log-transformed parameters, i.e. <span class="math inline">\({\boldsymbol{\varphi}}= (\log f_0, \log Q, \log R_{\textrm{w}})\)</span> which improves numerical optimization on an unconstrained scale;</li>
<li>computational parameterization, i.e. <span class="math inline">\({\boldsymbol{\varphi}}= (f_0, \gamma, R_{\textrm{w}})\)</span> where <span class="math inline">\(\gamma = f_0 Q\)</span> which is useful for profile likelihood estimation.</li>
</ul>
</div>
<div id="simple-harmonic-oscillator-with-1f-noise" class="section level2">
<h2>Simple Harmonic Oscillator with <span class="math inline">\(1/f\)</span> Noise</h2>
<p>The SHOF model is given by</p>
<p><span class="math display">\[\begin{equation}
\label{eq:shof}
\begin{aligned}
\operatorname{\mathcal S}(f, {\boldsymbol{\theta}}) &amp;= \frac{A_{\textrm{f}}}{f^\alpha} + \frac{k_BT/(k \cdot \pi f_0 Q)}{[(f/f_0)^2-1]^2 + [f/(f_0Q)]^2} \\
&amp;= \sigma^2 \times \left\{ \frac{R_{\textrm{f}}}{f^\alpha} + \frac{1}{[(f/f_0)^2-1]^2 + [f/\gamma]^2} \right\}
\end{aligned}
\end{equation}\]</span> where <span class="math inline">\(\sigma^2 = k_BT/(k\cdot \pi f_0Q)\)</span>, <span class="math inline">\(R_{\textrm{f}}= A_{\textrm{f}}/\sigma^2\)</span>, <span class="math inline">\(\gamma = f_0Q\)</span>, and <span class="math inline">\({\boldsymbol{\theta}}= (f_0, Q, R_{\textrm{f}}, \alpha)\)</span>.</p>
</div>
<div id="fractional-ornstein-uhlenbeck-model" class="section level2">
<h2>Fractional Ornstein-Uhlenbeck Model</h2>
<p>The fOU model is expressed as <span class="math display">\[
\mathrm{d}X(t) = -\gamma X(t)\, \mathrm{d}t + \tau \, \mathrm{d}B_t^H,
\]</span> where <span class="math inline">\(\gamma, \tau &gt; 0\)</span> and <span class="math inline">\(B_t^H\)</span> is fractional Brownian motion with Hurst parameter <span class="math inline">\(0 &lt; H &lt; 1\)</span>. The PSD for this model is <span class="math display">\[\begin{equation}
\label{eq:fcar}
\operatorname{\mathcal S}(f, {\boldsymbol{\theta}}) = \sigma^2 \times \frac{|f|^{1-2H}}{f^2 + \gamma^2},
\end{equation}\]</span> where <span class="math inline">\({\boldsymbol{\varphi}}= (H, \gamma)\)</span> and <span class="math inline">\(\sigma^2 = \tau^2 \cdot \Gamma(2H+1)\sin(\pi H)/(2\pi)\)</span>.</p>
</div>
<div id="carfima-models" class="section level2">
<h2>CARFIMA Models</h2>
<p>More generally, a <span class="math inline">\(\operatorname{CARFIMA}(p,q)\)</span> process is defined by the differential equation <span class="math display">\[
X_t^{(p)} = + \sum_{k=1}^{p-1} \alpha_k X_t^{(k-1)} + \tau \left[B_t^{H(1)} + \sum_{m=1}^{q} \beta_m B_t^{H(m+1)}\right],
\]</span> where <span class="math inline">\(X(t)\)</span> is stationary if and only if <span class="math display">\[
\alpha(x) = x^p - \sum_{k=1}^{p-1} \alpha_k x^{k-1} = \prod_{k=1}^p(x - r_k)
\]</span> is such that <span class="math inline">\(\mathscr R(r_k) &lt; 0\)</span> for <span class="math inline">\(k = 1,\ldots,p\)</span>. The PSD of the model is given by <span class="math display">\[\begin{equation}
\label{eq:carfima}
\operatorname{\mathcal S}(f, {\boldsymbol{\theta}}) = \sigma^2 \times \frac{|f|^{1-2H} \cdot |1 + \sum_{m=1}^q \beta_m (if)^m|^2}{|(if)^p - \sum_{k=1}^p \alpha_k (if)^{k-1}|^2}, 
\end{equation}\]</span> where <span class="math inline">\({\boldsymbol{\varphi}}= (H, {\boldsymbol{\alpha}}, {\boldsymbol{\beta}})\)</span>, and <span class="math inline">\(\sigma^2 = \tau^2 \cdot \Gamma(2H+1)\sin(\pi H)/(2\pi)\)</span>.<br />
<!-- , $0 < H < 1$, and $\aal = (\rv 1 \alpha q )$ and $\bbe = (\rv 1 \beta p )$ are such that the complex polynomials in the numerator and denominator of \\eqref{eq:carfima} have no roots in the unit circle.  The model parameters are $\pph = (\aal, \bbe, H)$. --> Since <strong>TMB</strong> does not support complex arithmetic, the polynomials are calculated as follows.</p>
<p>Consider a polynomial <span class="math inline">\(p(x) = \sum_{k=0}^p \alpha_k x^k\)</span> with <span class="math inline">\(\alpha_k \in \mathbb R\)</span>. <span class="math display">\[\begin{align*}
p(if) 
    &amp; = \sum_{k=0}^p \alpha_k (if)^k \\
    &amp; = \sum_{k=0}^{q} \alpha_{2k} (if)^{2k} + \sum_{k=0}^r \alpha_{2k+1} (if)^{2k+1} \\
    &amp; = \sum_{k=0}^q (-1)^k \alpha_{2k} f^{2k} + if\sum_{k=0}^r (-1)^k \alpha_{2k+1} f^{2k}
\end{align*}\]</span></p>
</div>
</div>
<div id="interfacing-with-tmb" class="section level1">
<h1>Interfacing with <strong>TMB</strong></h1>
<p><a href="https://CRAN.R-project.org/package=TMB"><strong>TMB</strong></a> is a great interface for R users to make use of the <a href="https://coin-or.github.io/CppAD/doc/cppad.htm"><strong>CppAD</strong></a> C++ library for <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a>. However, the study curve of <strong>TMB</strong> may be steep, especially for those new to this area. When <strong>realPSD</strong> was designed, we would like to make it as easy as possible for <strong>realPSD</strong> users to realize their models without dealing with <strong>TMB</strong> directly. The principle and coding practices are well explained <a href="https://github.com/mlysy/TMBtools#tmb-coding-practices">here</a>. It is strongly recommended to read the documentation in <a href="https://github.com/mlysy/TMBtools"><strong>TMBtools</strong></a> and the instructions <a href="https://github.com/kaskr/adcomp/wiki/Development#distributing-code">here</a> for those who are interested in using <strong>TMB</strong> to build flexible statistical models in R.</p>
<div id="external-constructor-for-user-defined-model-object" class="section level2">
<h2>External Constructor for User-defined Model Object</h2>
<p><strong>TMB</strong> and other source code (e.g., <a href="(http://www.rcpp.org/)"><strong>Rcpp</strong></a>) in an R package cannot be merged into a single shared library, as documented <a href="https://github.com/kaskr/adcomp/issues/247">here</a>. Therefore, the approach taken by <strong>realPSD</strong> is to have a separate shared object for the <strong>TMB</strong> models</p>
<p>If you still remember the OU example in the <a href="http://htmlpreview.github.io/?https://github.com/mlysy/realPSD/blob/devel-ferris-prerelease/doc/realPSD-quicktut.html">quick tutorial</a>, one of the necessary steps in writing your own model C++ header file is to include an external constructor like this</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#undef TMB_OBJECTIVE_PTR</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TMB_OBJECTIVE_PTR </span>obj</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// External constructor for `ou::UFun` objects.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">///</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// The arguments to this function are always `N` and `obj`.  Inside the function, we can specify additional TMB macros (`DATA_VECTOR`, etc.), to obtain inputs to the `UFun` constructor.</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">///</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// </span><span class="an">@param[in]</span><span class="co"> </span><span class="cv">N</span><span class="co"> Number of frequency/psd observations.</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// </span><span class="an">@param[in]</span><span class="co"> </span><span class="cv">obj</span><span class="co"> Pointer to the TMB object.</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// </span><span class="an">@return</span><span class="co"> An `ou::UFun` object.</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span>&lt;<span class="kw">class</span> Type&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  UFun&lt;Type&gt; make_Ufun(<span class="dt">int</span> N, objective_function&lt;Type&gt;* obj) {</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> UFun&lt;Type&gt;(N);</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#undef TMB_OBJECTIVE_PTR</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TMB_OBJECTIVE_PTR </span><span class="kw">this</span></span></code></pre></div>
<p>This is a workaround to let the TMB object pointer find the current model object (which is not built into the <strong>realPSD</strong> package).</p>
</div>
<div id="compile-on-the-fly" class="section level2">
<h2>Compile-on-the-fly</h2>
<p>To compile any user-defined model object on-the-fly, we make use of <a href="https://github.com/edwindj/whisker">whisker</a> to automatically create a template C++ file which is needed for <strong>TMB</strong> to compile the model correctly. The template was designed in a similar way as proposed by <a href="https://github.com/mlysy/TMBtools"><strong>TMBtools</strong></a>.</p>
<p>This technique has already been included into the built-in function <code>realPSD::make_psd_model</code>. Thus, users do not need to worry about how to realize this themselves. As we’ve already used in the OU example, by calling <code>make_psd_model</code> as follows</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create c++ file</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>ou_cpp <span class="ot">&lt;-</span> <span class="fu">make_psd_model</span>(<span class="at">model =</span> <span class="st">&quot;OU&quot;</span>,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                         <span class="at">header =</span> <span class="st">&quot;OU_Model.hpp&quot;</span>,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                         <span class="at">class =</span> <span class="st">&quot;ou::UFun&quot;</span>,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>                         <span class="at">ctor =</span> <span class="st">&quot;ou::make_Ufun&quot;</span>,</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>                         <span class="at">standalone =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p><strong>realPSD</strong> automatically generate a <code>.cpp</code> file under the current working directory (named <code>OU_FitMethods.cpp</code>) which contains the following content.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">@file</span><span class="co"> OU_Generics.hpp</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">/// </span><span class="an">@brief</span><span class="co"> Generic code which supplies everything needed to the **TMB** compiler for `OU`.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;TMB.hpp&gt;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;realPSD/FitMethods.hpp&quot;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;OU_Model.hpp&quot;</span><span class="pp"> </span><span class="co">// model class definition</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">// #include &quot;&quot; // the generic package code</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#undef TMB_OBJECTIVE_PTR</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TMB_OBJECTIVE_PTR </span>obj</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span>&lt;<span class="kw">class</span> Type&gt;</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>Type OU_Generics(objective_function&lt;Type&gt;* obj) {</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> realPSD::FitMethods&lt;Type, ou::UFun&lt;Type&gt; &gt;(obj, ou::make_Ufun&lt;Type&gt;);</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="pp">#undef TMB_OBJECTIVE_PTR</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TMB_OBJECTIVE_PTR </span><span class="kw">this</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span>&lt;<span class="kw">class</span> Type&gt;</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>Type objective_function&lt;Type&gt;::<span class="kw">operator</span>() () {</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>  DATA_STRING(model);</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(model == <span class="st">&quot;OU&quot;</span>) {</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OU_Generics&lt;Type&gt;(<span class="kw">this</span>);</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    error(<span class="st">&quot;Unknown model.&quot;</span>);</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> Type(<span class="fl">0.0</span>);</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This template allows users to put their models in separate header files from each other and compile the model using <strong>TMB</strong> correctly.</p>
</div>
<div id="wrap-the-model-object-by-r6-class" class="section level2">
<h2>Wrap the Model Object by R6 Class</h2>
<p>To let users to directly deal with <strong>TMB</strong> or the <code>FitMethods.hpp</code> in <strong>realPSD</strong> is not a wise choice and is very clumsy. Instead, we wrap the model object in an R6 class, which greatly streamlines the workflow of building and estimating process.</p>
<p><strong>realPSD</strong> provides three very important base classes in which we have already defined all the necessary infrastructures.</p>
<ul>
<li><code>psd_model</code> for any parametric PSD model</li>
<li><code>show_model</code> for any SHOW model (see the example below)</li>
<li><code>shof_model</code> for any SHO model with <span class="math inline">\(1/f\)</span> noise (see the example below)</li>
</ul>
<p>One can easily create a model object by using the <code>new()</code> method in the above R6 base classes. Therefore, fitting any PSD models or specifically any SHOW/SHOF models using <strong>realPSD</strong> is a very consistent process. If you are insterested in how we realize this, please check out the source code of <code>psd_model.R</code>. For more details about R6 class, one can see <a href="https://r6.r-lib.org/index.html">here</a>. For more details about how we defined the base class and how to use the methods therein, please see the documentation for each class.</p>
</div>
<div id="list-of-built-in-fitting-methods" class="section level2">
<h2>List of Built-in Fitting Methods</h2>
<p>For general users, the fitting methods specified in <code>FitMethods.hpp</code> are hidden. You don’t really need to know the underlying details, since <strong>realPSD</strong> has already handled (by using R6 class) choosing the proper fitting methods for you. But for adavanced users who are insterested in using <code>TMB::MakeADFun</code> directly, one can specify <code>method</code> as</p>
<ul>
<li><p><code>UFun</code>: evaluate U function <span class="math inline">\(U(f, {\boldsymbol{\varphi}})\)</span>.</p></li>
<li><p><code>MLE_ufun</code>: evaluate U function <span class="math inline">\(U_k({\boldsymbol{\varphi}})\)</span> for MLE method.</p></li>
<li><p><code>MLE_nll</code>: evaluate the negative log-likelihood function with proper scaling for MLE method.</p></li>
<li><p><code>MLE_nlp</code>: evaluate the profile likelihood with proper scaling for MLE method.</p></li>
<li><p><code>MLE_zeta</code>: evaluate <span class="math inline">\(\sigma^2\)</span> with proper scaling for MLE method.</p></li>
<li><p><code>MLE_res</code>: get the vector of residuals for MLE method.</p></li>
<li><p><code>LP_ufun</code>: evaluate <span class="math inline">\(\bar{U}_m({\boldsymbol{\varphi}})\)</span> for LP method.</p></li>
<li><p><code>LP_nll</code>: evaluate the negative log-likelihood function with proper scaling for LP method.</p></li>
<li><p><code>LP_nlp</code>: evaluate the profile likelihood with proper scaling for LP method.</p></li>
<li><p><code>LP_zeta</code>: evaluate <span class="math inline">\(\zeta\)</span> with proper scaling for LP method.</p></li>
<li><p><code>LP_res</code>: get the vector of residuals for LP method.</p></li>
<li><p><code>NLS_ufun</code>: evaluate U function <span class="math inline">\(U_k({\boldsymbol{\varphi}})\)</span> for NLS method.</p></li>
<li><p><code>NLS_nll</code>: evaluate the negative log-likelihood function with proper scaling for NLS method.</p></li>
<li><p><code>NLS_nlp</code>: evaluate the profile likelihood with proper scaling for NLS method.</p></li>
<li><p><code>NLS_zeta</code>: evaluate <span class="math inline">\(\sigma^2\)</span> with proper scaling for NLS method.</p></li>
<li><p><code>NLS_res</code>: get the vector of residuals for NLS method.</p></li>
</ul>
<!-- where $g_m(\tth) = (\bar Y_m - \bar{\psd}_m(\tth))^2$. -->
<!-- ## Implementation -->
<!-- ### Python -->
<!-- I'm not sure about OOP in Python, but in pseudo C++ I suggest we have a base class for each PSD model defined by $U(\f, \pph)$, and derived class for each method.  So for example: -->
<!-- ```{Rcpp, eval = FALSE} -->
<!-- class showModel { -->
<!-- // private/protected members here -->
<!-- public: -->
<!--   double UFun(const double f, const Vector& phi);   -->
<!-- }; -->
<!-- template <class Model> -->
<!-- class LPFit : public Model { -->
<!-- public: -->
<!--   // constructor: copy + allocate memory here -->
<!--   LPFit(const Vector& xPSD, const Vector& yPSD, const int binSize); -->
<!--   // conditional optimum of log_tau = log(tau) = log(sigma^2) -->
<!--   double logTauFit(const Vector& phi);       -->
<!--   // objective function: set up to minimize it -->
<!--   double obj(const Vector& phi); -->
<!--   // gradient & hessian -->
<!--   void grad(Vector& g, const Vector& phi); -->
<!--   void hess(Matrix& H, const Vector& phi); -->
<!--   // sometimes these re-use calculations from OFun. -->
<!--   // In that case, it's more efficient to have something like -->
<!--   double obj(Vector& g, Matrix& H, const Vector& phi); -->
<!--   // default optimization method. -->
<!--   //user has the option to do this manually with `obj`, `grad`, `hess` if -->
<!--   // default doesn't work. -->
<!--   // Or, simply don't provide a default if it's too complicated! -->
<!--   void fit(Vector& phi, double& logTau, const Vector& phiInit, -->
<!--            ...); // ellipsis is for additional tuning parameters -->
<!--   // variance estimator -->
<!--   void var(Matrix& V, const Vector& phi, const double logTau); -->
<!-- }; -->
<!-- ``` -->
<!-- Some useful Python packages: -->
<!-- - [**autograd**](https://github.com/HIPS/autograd): Automatic differentiation of Python and Numpy functions. -->
<!-- - [**NLopt**](https://nlopt.readthedocs.io/en/latest/): Excellent nonlinear optimization library, with Python interface.  I suggest using gradient-based algorithms in combination with the above. -->
<!-- Other functions the library should contain: -->
<!-- - `tsSim`: Simulate time series with given PSD. -->
<!-- - `periodogram`: Calculate the periodogram of a time series. -->
<!-- - `fisherGstat`: For denoising. -->
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
